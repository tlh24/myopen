// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spikes.proto

#ifndef PROTOBUF_spikes_2eproto__INCLUDED
#define PROTOBUF_spikes_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_spikes_2eproto();
void protobuf_AssignDesc_spikes_2eproto();
void protobuf_ShutdownFile_spikes_2eproto();

class Spike_msg;
class Display_msg;

// ===================================================================

class Spike_msg : public ::google::protobuf::Message {
 public:
  Spike_msg();
  virtual ~Spike_msg();
  
  Spike_msg(const Spike_msg& from);
  
  inline Spike_msg& operator=(const Spike_msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Spike_msg& default_instance();
  
  void Swap(Spike_msg* other);
  
  // implements Message ----------------------------------------------
  
  Spike_msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Spike_msg& from);
  void MergeFrom(const Spike_msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 ts = 1;
  inline bool has_ts() const;
  inline void clear_ts();
  static const int kTsFieldNumber = 1;
  inline ::google::protobuf::uint64 ts() const;
  inline void set_ts(::google::protobuf::uint64 value);
  
  // required uint32 chan = 2;
  inline bool has_chan() const;
  inline void clear_chan();
  static const int kChanFieldNumber = 2;
  inline ::google::protobuf::uint32 chan() const;
  inline void set_chan(::google::protobuf::uint32 value);
  
  // optional uint32 unit = 3;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 3;
  inline ::google::protobuf::uint32 unit() const;
  inline void set_unit(::google::protobuf::uint32 value);
  
  // optional bytes w = 6;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 6;
  inline const ::std::string& w() const;
  inline void set_w(const ::std::string& value);
  inline void set_w(const char* value);
  inline void set_w(const void* value, size_t size);
  inline ::std::string* mutable_w();
  inline ::std::string* release_w();
  
  // optional uint32 seq = 7;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 7;
  inline ::google::protobuf::uint32 seq() const;
  inline void set_seq(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:Spike_msg)
 private:
  inline void set_has_ts();
  inline void clear_has_ts();
  inline void set_has_chan();
  inline void clear_has_chan();
  inline void set_has_unit();
  inline void clear_has_unit();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_seq();
  inline void clear_has_seq();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 ts_;
  ::google::protobuf::uint32 chan_;
  ::google::protobuf::uint32 unit_;
  ::std::string* w_;
  ::google::protobuf::uint32 seq_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_spikes_2eproto();
  friend void protobuf_AssignDesc_spikes_2eproto();
  friend void protobuf_ShutdownFile_spikes_2eproto();
  
  void InitAsDefaultInstance();
  static Spike_msg* default_instance_;
};
// -------------------------------------------------------------------

class Display_msg : public ::google::protobuf::Message {
 public:
  Display_msg();
  virtual ~Display_msg();
  
  Display_msg(const Display_msg& from);
  
  inline Display_msg& operator=(const Display_msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Display_msg& default_instance();
  
  void Swap(Display_msg* other);
  
  // implements Message ----------------------------------------------
  
  Display_msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Display_msg& from);
  void MergeFrom(const Display_msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated double cursor = 1;
  inline int cursor_size() const;
  inline void clear_cursor();
  static const int kCursorFieldNumber = 1;
  inline double cursor(int index) const;
  inline void set_cursor(int index, double value);
  inline void add_cursor(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      cursor() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_cursor();
  
  // repeated double target = 2;
  inline int target_size() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 2;
  inline double target(int index) const;
  inline void set_target(int index, double value);
  inline void add_target(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      target() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_target();
  
  // optional bool touch = 3;
  inline bool has_touch() const;
  inline void clear_touch();
  static const int kTouchFieldNumber = 3;
  inline bool touch() const;
  inline void set_touch(bool value);
  
  // optional bool juicer = 4;
  inline bool has_juicer() const;
  inline void clear_juicer();
  static const int kJuicerFieldNumber = 4;
  inline bool juicer() const;
  inline void set_juicer(bool value);
  
  // optional bool manual = 5;
  inline bool has_manual() const;
  inline void clear_manual();
  static const int kManualFieldNumber = 5;
  inline bool manual() const;
  inline void set_manual(bool value);
  
  // optional float cursorSize = 6;
  inline bool has_cursorsize() const;
  inline void clear_cursorsize();
  static const int kCursorSizeFieldNumber = 6;
  inline float cursorsize() const;
  inline void set_cursorsize(float value);
  
  // optional float targetSize = 7;
  inline bool has_targetsize() const;
  inline void clear_targetsize();
  static const int kTargetSizeFieldNumber = 7;
  inline float targetsize() const;
  inline void set_targetsize(float value);
  
  // optional float cursorAlpha = 8;
  inline bool has_cursoralpha() const;
  inline void clear_cursoralpha();
  static const int kCursorAlphaFieldNumber = 8;
  inline float cursoralpha() const;
  inline void set_cursoralpha(float value);
  
  // optional float targetAlpha = 9;
  inline bool has_targetalpha() const;
  inline void clear_targetalpha();
  static const int kTargetAlphaFieldNumber = 9;
  inline float targetalpha() const;
  inline void set_targetalpha(float value);
  
  // optional float irDiff = 10;
  inline bool has_irdiff() const;
  inline void clear_irdiff();
  static const int kIrDiffFieldNumber = 10;
  inline float irdiff() const;
  inline void set_irdiff(float value);
  
  // repeated float bgColor = 11;
  inline int bgcolor_size() const;
  inline void clear_bgcolor();
  static const int kBgColorFieldNumber = 11;
  inline float bgcolor(int index) const;
  inline void set_bgcolor(int index, float value);
  inline void add_bgcolor(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      bgcolor() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_bgcolor();
  
  // @@protoc_insertion_point(class_scope:Display_msg)
 private:
  inline void set_has_touch();
  inline void clear_has_touch();
  inline void set_has_juicer();
  inline void clear_has_juicer();
  inline void set_has_manual();
  inline void clear_has_manual();
  inline void set_has_cursorsize();
  inline void clear_has_cursorsize();
  inline void set_has_targetsize();
  inline void clear_has_targetsize();
  inline void set_has_cursoralpha();
  inline void clear_has_cursoralpha();
  inline void set_has_targetalpha();
  inline void clear_has_targetalpha();
  inline void set_has_irdiff();
  inline void clear_has_irdiff();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< double > cursor_;
  ::google::protobuf::RepeatedField< double > target_;
  bool touch_;
  bool juicer_;
  bool manual_;
  float cursorsize_;
  float targetsize_;
  float cursoralpha_;
  float targetalpha_;
  float irdiff_;
  ::google::protobuf::RepeatedField< float > bgcolor_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_spikes_2eproto();
  friend void protobuf_AssignDesc_spikes_2eproto();
  friend void protobuf_ShutdownFile_spikes_2eproto();
  
  void InitAsDefaultInstance();
  static Display_msg* default_instance_;
};
// ===================================================================


// ===================================================================

// Spike_msg

// required uint64 ts = 1;
inline bool Spike_msg::has_ts() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Spike_msg::set_has_ts() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Spike_msg::clear_has_ts() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Spike_msg::clear_ts() {
  ts_ = GOOGLE_ULONGLONG(0);
  clear_has_ts();
}
inline ::google::protobuf::uint64 Spike_msg::ts() const {
  return ts_;
}
inline void Spike_msg::set_ts(::google::protobuf::uint64 value) {
  set_has_ts();
  ts_ = value;
}

// required uint32 chan = 2;
inline bool Spike_msg::has_chan() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Spike_msg::set_has_chan() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Spike_msg::clear_has_chan() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Spike_msg::clear_chan() {
  chan_ = 0u;
  clear_has_chan();
}
inline ::google::protobuf::uint32 Spike_msg::chan() const {
  return chan_;
}
inline void Spike_msg::set_chan(::google::protobuf::uint32 value) {
  set_has_chan();
  chan_ = value;
}

// optional uint32 unit = 3;
inline bool Spike_msg::has_unit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Spike_msg::set_has_unit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Spike_msg::clear_has_unit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Spike_msg::clear_unit() {
  unit_ = 0u;
  clear_has_unit();
}
inline ::google::protobuf::uint32 Spike_msg::unit() const {
  return unit_;
}
inline void Spike_msg::set_unit(::google::protobuf::uint32 value) {
  set_has_unit();
  unit_ = value;
}

// optional bytes w = 6;
inline bool Spike_msg::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Spike_msg::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Spike_msg::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Spike_msg::clear_w() {
  if (w_ != &::google::protobuf::internal::kEmptyString) {
    w_->clear();
  }
  clear_has_w();
}
inline const ::std::string& Spike_msg::w() const {
  return *w_;
}
inline void Spike_msg::set_w(const ::std::string& value) {
  set_has_w();
  if (w_ == &::google::protobuf::internal::kEmptyString) {
    w_ = new ::std::string;
  }
  w_->assign(value);
}
inline void Spike_msg::set_w(const char* value) {
  set_has_w();
  if (w_ == &::google::protobuf::internal::kEmptyString) {
    w_ = new ::std::string;
  }
  w_->assign(value);
}
inline void Spike_msg::set_w(const void* value, size_t size) {
  set_has_w();
  if (w_ == &::google::protobuf::internal::kEmptyString) {
    w_ = new ::std::string;
  }
  w_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Spike_msg::mutable_w() {
  set_has_w();
  if (w_ == &::google::protobuf::internal::kEmptyString) {
    w_ = new ::std::string;
  }
  return w_;
}
inline ::std::string* Spike_msg::release_w() {
  clear_has_w();
  if (w_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = w_;
    w_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 seq = 7;
inline bool Spike_msg::has_seq() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Spike_msg::set_has_seq() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Spike_msg::clear_has_seq() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Spike_msg::clear_seq() {
  seq_ = 0u;
  clear_has_seq();
}
inline ::google::protobuf::uint32 Spike_msg::seq() const {
  return seq_;
}
inline void Spike_msg::set_seq(::google::protobuf::uint32 value) {
  set_has_seq();
  seq_ = value;
}

// -------------------------------------------------------------------

// Display_msg

// repeated double cursor = 1;
inline int Display_msg::cursor_size() const {
  return cursor_.size();
}
inline void Display_msg::clear_cursor() {
  cursor_.Clear();
}
inline double Display_msg::cursor(int index) const {
  return cursor_.Get(index);
}
inline void Display_msg::set_cursor(int index, double value) {
  cursor_.Set(index, value);
}
inline void Display_msg::add_cursor(double value) {
  cursor_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Display_msg::cursor() const {
  return cursor_;
}
inline ::google::protobuf::RepeatedField< double >*
Display_msg::mutable_cursor() {
  return &cursor_;
}

// repeated double target = 2;
inline int Display_msg::target_size() const {
  return target_.size();
}
inline void Display_msg::clear_target() {
  target_.Clear();
}
inline double Display_msg::target(int index) const {
  return target_.Get(index);
}
inline void Display_msg::set_target(int index, double value) {
  target_.Set(index, value);
}
inline void Display_msg::add_target(double value) {
  target_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Display_msg::target() const {
  return target_;
}
inline ::google::protobuf::RepeatedField< double >*
Display_msg::mutable_target() {
  return &target_;
}

// optional bool touch = 3;
inline bool Display_msg::has_touch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Display_msg::set_has_touch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Display_msg::clear_has_touch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Display_msg::clear_touch() {
  touch_ = false;
  clear_has_touch();
}
inline bool Display_msg::touch() const {
  return touch_;
}
inline void Display_msg::set_touch(bool value) {
  set_has_touch();
  touch_ = value;
}

// optional bool juicer = 4;
inline bool Display_msg::has_juicer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Display_msg::set_has_juicer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Display_msg::clear_has_juicer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Display_msg::clear_juicer() {
  juicer_ = false;
  clear_has_juicer();
}
inline bool Display_msg::juicer() const {
  return juicer_;
}
inline void Display_msg::set_juicer(bool value) {
  set_has_juicer();
  juicer_ = value;
}

// optional bool manual = 5;
inline bool Display_msg::has_manual() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Display_msg::set_has_manual() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Display_msg::clear_has_manual() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Display_msg::clear_manual() {
  manual_ = false;
  clear_has_manual();
}
inline bool Display_msg::manual() const {
  return manual_;
}
inline void Display_msg::set_manual(bool value) {
  set_has_manual();
  manual_ = value;
}

// optional float cursorSize = 6;
inline bool Display_msg::has_cursorsize() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Display_msg::set_has_cursorsize() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Display_msg::clear_has_cursorsize() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Display_msg::clear_cursorsize() {
  cursorsize_ = 0;
  clear_has_cursorsize();
}
inline float Display_msg::cursorsize() const {
  return cursorsize_;
}
inline void Display_msg::set_cursorsize(float value) {
  set_has_cursorsize();
  cursorsize_ = value;
}

// optional float targetSize = 7;
inline bool Display_msg::has_targetsize() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Display_msg::set_has_targetsize() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Display_msg::clear_has_targetsize() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Display_msg::clear_targetsize() {
  targetsize_ = 0;
  clear_has_targetsize();
}
inline float Display_msg::targetsize() const {
  return targetsize_;
}
inline void Display_msg::set_targetsize(float value) {
  set_has_targetsize();
  targetsize_ = value;
}

// optional float cursorAlpha = 8;
inline bool Display_msg::has_cursoralpha() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Display_msg::set_has_cursoralpha() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Display_msg::clear_has_cursoralpha() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Display_msg::clear_cursoralpha() {
  cursoralpha_ = 0;
  clear_has_cursoralpha();
}
inline float Display_msg::cursoralpha() const {
  return cursoralpha_;
}
inline void Display_msg::set_cursoralpha(float value) {
  set_has_cursoralpha();
  cursoralpha_ = value;
}

// optional float targetAlpha = 9;
inline bool Display_msg::has_targetalpha() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Display_msg::set_has_targetalpha() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Display_msg::clear_has_targetalpha() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Display_msg::clear_targetalpha() {
  targetalpha_ = 0;
  clear_has_targetalpha();
}
inline float Display_msg::targetalpha() const {
  return targetalpha_;
}
inline void Display_msg::set_targetalpha(float value) {
  set_has_targetalpha();
  targetalpha_ = value;
}

// optional float irDiff = 10;
inline bool Display_msg::has_irdiff() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Display_msg::set_has_irdiff() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Display_msg::clear_has_irdiff() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Display_msg::clear_irdiff() {
  irdiff_ = 0;
  clear_has_irdiff();
}
inline float Display_msg::irdiff() const {
  return irdiff_;
}
inline void Display_msg::set_irdiff(float value) {
  set_has_irdiff();
  irdiff_ = value;
}

// repeated float bgColor = 11;
inline int Display_msg::bgcolor_size() const {
  return bgcolor_.size();
}
inline void Display_msg::clear_bgcolor() {
  bgcolor_.Clear();
}
inline float Display_msg::bgcolor(int index) const {
  return bgcolor_.Get(index);
}
inline void Display_msg::set_bgcolor(int index, float value) {
  bgcolor_.Set(index, value);
}
inline void Display_msg::add_bgcolor(float value) {
  bgcolor_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
Display_msg::bgcolor() const {
  return bgcolor_;
}
inline ::google::protobuf::RepeatedField< float >*
Display_msg::mutable_bgcolor() {
  return &bgcolor_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_spikes_2eproto__INCLUDED
