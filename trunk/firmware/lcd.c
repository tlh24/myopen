#include <cdefBF537.h>
#include "memory.h"
#include "lcd.h"
// lcd_cs = portf 4 ; set low when writing 9 bits. 
// lcd_clk = portg 5; data is clocked in on the rising edge.
// lcd_data = portg 4 ; data is msb first. 
#define LCD_CS  0x10 //should be 0x10
#define LCD_CLK  0x20 
#define LCD_DATA 0x10
#define LCD_RESET 0x08
#define LCD_DELAY 1
#define SSYNC asm volatile ("ssync")
extern void delay(int); 

static unsigned char s_apxFont5x9[440] =
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xD2, 0xD0, 0x00, 0x00, 
	0x01, 0x5F, 0x52, 0xBE, 0xA0, 0x00, 0x8F, 0xA3, 0x8B, 0xE2, 
	0x00, 0x00, 0x88, 0x88, 0x88, 0x80, 0x00, 0x45, 0x28, 0x8A, 
	0xC9, 0xA0, 0x02, 0xC0, 0x00, 0xD5, 0x52, 0x4A, 0xAB, 0x00, 
	0x25, 0x5D, 0x52, 0x00, 0x00, 0x01, 0x09, 0xF2, 0x10, 0x00, 
	0x00, 0x00, 0xB0, 0x00, 0x03, 0xE0, 0x00, 0x00, 0x00, 0x20, 
	0x02, 0x22, 0x22, 0x00, 0x00, 0x1D, 0x19, 0xD7, 0x31, 0x70, 
	0x00, 0x46, 0x10, 0x84, 0x23, 0x80, 0x07, 0x44, 0x26, 0x44, 
	0x3E, 0x00, 0x3A, 0x21, 0x30, 0x62, 0xE0, 0x00, 0x46, 0x54, 
	0xBE, 0x21, 0x00, 0x1F, 0x87, 0x82, 0x18, 0xB8, 0x00, 0x74, 
	0x3D, 0x18, 0xC5, 0xC0, 0x07, 0xC2, 0x22, 0x21, 0x08, 0x00, 
	0x1D, 0x18, 0xBA, 0x31, 0x70, 0x00, 0xE8, 0xC6, 0x2F, 0x0B, 
	0x80, 0x02, 0x40, 0x20, 0xB0, 0x0A, 0x88, 0x80, 0x00, 0x0F, 
	0x83, 0xE0, 0x00, 0x00, 0x22, 0x2A, 0x00, 0x1D, 0x10, 0x88, 
	0x80, 0x20, 0x00, 0x07, 0x46, 0xB7, 0x83, 0x80, 0x02, 0x2A, 
	0x31, 0xFC, 0x62, 0x00, 0x7A, 0x31, 0xF4, 0x63, 0xE0, 0x01, 
	0xD1, 0x84, 0x21, 0x17, 0x00, 0x1C, 0x94, 0x63, 0x19, 0x70, 
	0x00, 0xFC, 0x21, 0xE8, 0x43, 0xE0, 0x07, 0xE1, 0x0F, 0x42, 
	0x10, 0x00, 0x1D, 0x18, 0x42, 0x71, 0x70, 0x01, 0x18, 0xC7, 
	0xF1, 0x8C, 0x40, 0x0E, 0x92, 0x4B, 0x80, 0xF1, 0x08, 0x42, 
	0x93, 0x00, 0x08, 0xCA, 0x98, 0xA4, 0xA2, 0x00, 0x42, 0x10, 
	0x84, 0x21, 0xF0, 0x02, 0x3B, 0xAD, 0x63, 0x18, 0x80, 0x11, 
	0xCD, 0x6B, 0x59, 0xC4, 0x00, 0x74, 0x63, 0x18, 0xC5, 0xC0, 
	0x07, 0xA3, 0x18, 0xFA, 0x10, 0x00, 0x1D, 0x18, 0xC6, 0xB2, 
	0x68, 0x01, 0xE8, 0xC6, 0x3E, 0x8C, 0x40, 0x07, 0x46, 0x0E, 
	0x0C, 0x5C, 0x00, 0x7C, 0x84, 0x21, 0x08, 0x40, 0x02, 0x31, 
	0x8C, 0x63, 0x17, 0x00, 0x11, 0x8C, 0x54, 0xA2, 0x10, 0x00, 
	0x8C, 0x63, 0x5A, 0xA9, 0x40, 0x04, 0x62, 0xA2, 0x2A, 0x31, 
	0x00, 0x23, 0x18, 0xA8, 0x84, 0x20, 0x01, 0xF0, 0x88, 0x88, 
	0x87, 0xC0, 0x0E, 0xAA, 0xB0, 0x10, 0x41, 0x04, 0x10, 0x00, 
	0x1A, 0xAA, 0xE1, 0x15, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xF8, 0x01, 0x48, 0x00, 0x00, 0x30, 0xBC, 0xB8, 
	0x04, 0x47, 0x4C, 0xCF, 0x00, 0x00, 0x3C, 0x44, 0x38, 0x00, 
	0x8B, 0xCC, 0xCB, 0x80, 0x00, 0x34, 0xF4, 0x38, 0x01, 0xA2, 
	0x72, 0x22, 0x00, 0x00, 0x34, 0xCC, 0xB8, 0xB4, 0x47, 0x4C, 
	0xCC, 0x80, 0x5F, 0x11, 0x55, 0x68, 0x89, 0xAC, 0xA9, 0x00, 
	0xAA, 0xA4, 0x00, 0x0D, 0x56, 0xB5, 0xA8, 0x00, 0x01, 0xD3, 
	0x33, 0x20, 0x00, 0x0D, 0x33, 0x2C, 0x00, 0x01, 0xD3, 0x33, 
	0xD1, 0x00, 0x0F, 0x33, 0x2E, 0x22, 0x01, 0x79, 0x11, 0x00, 
	0x00, 0x0D, 0x0C, 0x3C, 0x00, 0x97, 0x49, 0x10, 0x00, 0x26, 
	0x66, 0x5C, 0x00, 0x02, 0x66, 0x69, 0x00, 0x00, 0x08, 0xC6, 
	0xB5, 0x50, 0x00, 0x00, 0x45, 0x44, 0x54, 0x40, 0x00, 0x09, 
	0x99, 0x97, 0x16, 0x00, 0xF2, 0x48, 0xF0, 0x02, 0x94, 0x49, 
	0x11, 0xFC, 0x89, 0x14, 0x94, 0x0B, 0x40, 0x00, 0x00, 0x00
}; /* 440 bytes */

/* array of starting column for each char (with extra entry at end
   for calculating the width of the last char) */
static unsigned short s_mpchxFont5x9[96] =
{
	  0, /* ' ' */    5, /* '!' */    6, /* '"' */    9, /* '#' */   14, /* '$' */
	 19, /* '%' */   24, /* '&' */   29, /* ''' */   31, /* '(' */   33, /* ')' */
	 35, /* '*' */   40, /* '+' */   45, /* ',' */   47, /* '-' */   52, /* '.' */
	 53, /* '/' */   58, /* '0' */   63, /* '1' */   68, /* '2' */   73, /* '3' */
	 78, /* '4' */   83, /* '5' */   88, /* '6' */   93, /* '7' */   98, /* '8' */
	103, /* '9' */  108, /* ':' */  109, /* ';' */  111, /* '<' */  114, /* '=' */
	119, /* '>' */  122, /* '?' */  127, /* '@' */  132, /* 'A' */  137, /* 'B' */
	142, /* 'C' */  147, /* 'D' */  152, /* 'E' */  157, /* 'F' */  162, /* 'G' */
	167, /* 'H' */  172, /* 'I' */  175, /* 'J' */  180, /* 'K' */  185, /* 'L' */
	190, /* 'M' */  195, /* 'N' */  200, /* 'O' */  205, /* 'P' */  210, /* 'Q' */
	215, /* 'R' */  220, /* 'S' */  225, /* 'T' */  230, /* 'U' */  235, /* 'V' */
	240, /* 'W' */  245, /* 'X' */  250, /* 'Y' */  255, /* 'Z' */  260, /* '[' */
	262, /* '\' */  267, /* ']' */  269, /* '^' */  274, /* '_' */  279, /* '`' */
	281, /* 'a' */  285, /* 'b' */  289, /* 'c' */  293, /* 'd' */  297, /* 'e' */
	301, /* 'f' */  305, /* 'g' */  309, /* 'h' */  313, /* 'i' */  314, /* 'j' */
	316, /* 'k' */  320, /* 'l' */  322, /* 'm' */  327, /* 'n' */  331, /* 'o' */
	335, /* 'p' */  339, /* 'q' */  343, /* 'r' */  347, /* 's' */  351, /* 't' */
	354, /* 'u' */  358, /* 'v' */  362, /* 'w' */  367, /* 'x' */  372, /* 'y' */
	376, /* 'z' */  380, /* '{' */  383, /* '|' */  384, /* '}' */  387, /* '~' */
	391
};


void LCD_send(char data, unsigned char word){
	unsigned short r = (unsigned short) word; 
	if(data) r |= 0x100; 
	*pPORTFIO_CLEAR = LCD_CS ;
	int i; 
	for(i=0; i<9 ; i++){
		*pPORTGIO_CLEAR = LCD_CLK; 
		if (r & 0x100) *pPORTGIO_SET = LCD_DATA; 
		else *pPORTGIO_CLEAR = LCD_DATA; 
		SSYNC ; 
		r = r << 1; 
		//delay(LCD_DELAY); 
		*pPORTGIO_SET = LCD_CLK; 
		SSYNC ; 
		//delay(LCD_DELAY); 
	}
	*pPORTFIO_SET = LCD_CS ;
	SSYNC ; 
	//delay(LCD_DELAY); 
}
void LCD_command(unsigned char word){
	LCD_send(0,word); 
}
void LCD_data(unsigned char word){
	LCD_send(1,word); 
}
//  sets the starting page(row) and column (x & y) coordinates in ram,
//  then writes the colour to display memory.  The ending x & y are left
//  maxed out so one can continue sending colour data bytes to the 'open'
//  RAMWR command to fill further memory.  issuing any other command
//  finishes RAMWR.
void pset(unsigned char color, 
	unsigned char x, unsigned char y,
	unsigned char ex, unsigned char ey)
{
	LCD_command(PASET);   // page start/end ram
	LCD_data(x);
	LCD_data(ex);

	LCD_command(CASET);   // column start/end ram
	LCD_data(y);
	LCD_data(ey);

	LCD_command(RAMWR);    // write
	LCD_data(color);
}
void LCD_init() {
	//while(1){
	*pPORTGIO_CLEAR = LCD_RESET; 
	delay(500); 
	*pPORTGIO_SET = LCD_RESET; 
	delay(500); 
	LCD_command(DISCTL);  	// display control(EPSON)
	LCD_data(0x0C);   	// 12 = 1100 - CL dividing ratio [don't divide] switching period 8H (default)
	LCD_data(0x20);
	LCD_data(0x02);
	
	LCD_command(COMSCN);  	// common scanning direction(EPSON)
	LCD_data(0x01);
	
	LCD_command(OSCON);  	// internal oscialltor ON(EPSON)
	
	LCD_command(SLPOUT);  	// sleep out(EPSON)
	LCD_command(SLEEPOUT);	//sleep out(PHILLIPS)
	
	LCD_command(VOLCTR);  	// electronic volume, this is the contrast/brightness(EPSON)
	LCD_data(0x18);   	// volume (contrast) setting - fine tuning, original
	LCD_data(0x03);   	// internal resistor ratio - coarse adjustment
	LCD_command(SETCON);	//Set Contrast(PHILLIPS)
	LCD_data(0x30);	
	
	
	LCD_command(PWRCTR); 	// power ctrl(EPSON)
	LCD_data(0x0F);    //everything on, no external reference resistors
	LCD_command(BSTRON);	//Booset On(PHILLIPS)
	
	LCD_command(DISINV);  	// invert display mode(EPSON)
	LCD_command(INVON);	// invert display mode(PHILLIPS)
	
	LCD_command(DATCTL);  	// data control(EPSON)
	LCD_data(0x03);	//correct for normal sin7
	LCD_data(0x00);   	// normal RGB arrangement
	LCD_data(0x01);   	// 8-bit grayscale
	LCD_command(MADCTL);	//Memory Access Control(PHILLIPS)
	LCD_data(0xC8);
	
	LCD_command(COLMOD);	//Set Color Mode(PHILLIPS)
	LCD_data(0x02);	
	
	
	LCD_command(RGBSET8);   // setup 8-bit color lookup table  [RRRGGGBB](EPSON)
	//RED
	LCD_data(0);
	LCD_data(2);
	LCD_data(4);
	LCD_data(6);
	LCD_data(8);
	LCD_data(10);
	LCD_data(12);
	LCD_data(15);
	// GREEN
	LCD_data(0);
	LCD_data(2);
	LCD_data(4);
	LCD_data(6);
	LCD_data(8);
	LCD_data(10);
	LCD_data(12);
	LCD_data(15);
	//BLUE
	LCD_data(5);
	LCD_data(13);
	LCD_data(14);
	LCD_data(15);
	
	LCD_command(NOP);  	// nop(EPSON)
	LCD_command(NOPP);		// nop(PHILLIPS)

	LCD_command(DISON);   	// display on(EPSON)
	LCD_command(DISPON);	// display on(PHILLIPS)
	unsigned char c = 0; 
	unsigned char x = 0; 
	unsigned char y = 0; 
	while(1) {
		pset(c, x, y, x+11, y+11);
		int i; 
		for (i=1; i< 11*11; i++){
			LCD_data(c); 
		}
		c++; 
		c &= 0xff; 
		x++; 
		if (x & 0x1) y++; 
		if( x > 117) x = 0; 
		if(y > 112) y = 0; 
		LCD_command(0); 
	}
}